---
layout: default
permalink: /learning-objectives
---

<h2 class="obj">Written Learning Objectives for CIS352</h2>

The following learning objectives will be formally assessed via
written (or typed) exam throughout the term of CIS352. Each learning
objective will be turned into a written exam question which students
will have the opportunity to complete during quizzes / final.

The student must be able to...

<ol class="outcomes">
<li><a href="#lo1"></a>Identify expressions, forms, and callsites (in Racket).</li>

<li><a href="#lo2"></a>Implement traditional recursive algorithms in
direct style using numbers, lists, and conditionals.</li>

<li><a href="#lo3"></a>Differentiate tail calls (and tail
recursion) vs. direct-style calls; be able to implement tail-recursive
list accumulation algorithms.</li>

<li><a href="#lo4"></a>Draw cons diagrams for arbitrary
tree-shaped (Racket) data and (at a high level) explain its relation
to layout in RAM / cache.</li>

<li><a href="#lo5"></a>Use (and define) maps over lists
and tree-shaped data.</li>

<li><a href="#lo6"></a>Use (and define) folds (such as foldl/foldr) to
accumulate results of traversals over lists.</li>

<li><a href="#lo7"></a>Perform common (beta, alpha, eta) reductions /
conversions for the lambda calculus; evaluate lambda calculus terms
to normal form using various reduction strategies, including
call-by-name/value.</li>

<li><a href="#lo8"></a>Perform Church encoding by hand on small
programs using numbers, cons cells, recursion, primitive arithmetic
operations, let-binding, and application. Be able to evaluate such
terms to normal forms.</li>

<li><a href="lo9"></a>Identify the reduction context for a given
dynamic extent.</li>

<li><a href="lo10"></a>Use continuations to implement various
higher-order control idioms, including preemptive returns, exceptions,
loops, and coroutines.</li>

<li><a href="lo11"></a>Identify properties guaranteed by the
type-soundness theorem for the simply-typed lambda calculus.</li>

<li><a href="lo12"></a>Write natural-deduction-style proof trees for
correctly-typed terms in the lambda calculus, or explain (in english
prose or using partial proof trees) when terms are ill-typed.</li>

 </ol>
